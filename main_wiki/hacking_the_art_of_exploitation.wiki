= HACKING - The Art Of Exploitation =

== 0x100 Introduction ==
Before computers, some hackers were interested in railroads. Hacking is solving
problems in an eloquent manner. The community gives no significance to age,
race, gender, appearance, academic degrees and social status. The goal is to
advance the art.

"Hacker Ethic: the appreciation of logic as an art form and the promotion of
the free flow of information, surmounting conventional boundaries and
restrictions for the simple goal of better understanding the world."

"The Digital Millenium Copyright Act (DMCA) of 1998 makes it illegal to discuss
or provide technology that might be used to bypass industry consumer controls."
This law has been used for justify an arrest.

There is an ongoing competition in security field. Defenders and attackers try
to constantly up their game, which leads to overall more secure systems.
- Own thought on this:
	- Software complexity will increase when more security measures are
	  added. Temporarily this may lead to program instability and now this
	  needs to be fixed. At some point, there will be a need to simplify if
	  possible. After the security improvements, stability fixes and
	  simplification, the resulting program/system should be closer to
	  fulfilling its intended purpose. The amount of software/code will
	  most likely have increased from the start though. Complexity of a
	  problem dictates the minimum amount of complexity needed in a
	  solution. It is easy to misjudge the amount of complexity in both
	  problems and solutiuons.

Everyone is invited to embrace the true hacker spirit.

== 0x200 Programming ==
Programs are not necessarily executable computer programs. For example driving
instructions can be thought of as a program.

A computer does not understand English. Machine language is required in order
to communicate with a computer. As machine language consists of only bits, it
is cumbersome to work with. A translator helps a programmer in communicating
with computer more efficiently. Assemblers and compilers are translators,
assembler being the more primitive one, producing machine languge.

Pseudo-code can be used when designing a program.

Some essential concepts:
    * branching/if statements
    * variables
    * loops
        * while
        * for
        * until
    * arithmetic operators
    * comparison operators
    * functions

objdump -M intel -D ./a.out | grep -A20 main.:
objdump --disassembler-options intel --disassemble-all ./a.out | grep -A20 main.:

64-bit processors have 48-bit address space. They can also run in 32-bit
compatibility mode.

The processor can be instructed to:
    * read/write memory
    * perform math
    * be interrupted

In addition to RAM, processors can operate on registers, which can store
bits/bytes.

Registers:
    * EAX <- Accumulator
    * EBX <- Base
    * ECX <- Counter
    * EDX <- Data
    * ESP <- Stack Pointer
    * EBP <- Base Pointer
    * ESI <- Source Index
    * EDI <- Destination Index
    * EIP <- Instruction Pointer
    * EFLAGS <- bit flags for comparisons and memory segmentation

gcc -g firstprog.c # -g for getting debug symbols. For examle 'list' won't work otherwise

gdb -q ./a.out

(gdb) set disassembly intel # This command can be added to ~/.gdbinit
(gdb) list
(gdb) break 8
(gdb) run
(gdb) x/5i $pc
(gdb) stepi
(gdb) help p
(gdb) printf "%c", *(char *)<address>
(gdb) printf "%s", (char *)<address>
(gdb) info registers
(gdb) c # continue
(gdb) display/i $pc

== 0x300 Exploitation ==
== 0x400 Networking ==
== 0x500 Shellcode ==
== 0x600 Countermeasures ==
== 0x700 Cryptology ==
== 0x800 Conclusion ==
