= HACKING - The Art Of Exploitation =

== 0x100 Introduction ==
Before computers, some hackers were interested in railroads. Hacking is solving
problems in an eloquent manner. The community gives no significance to age,
race, gender, appearance, academic degrees and social status. The goal is to
advance the art.

"Hacker Ethic: the appreciation of logic as an art form and the promotion of
the free flow of information, surmounting conventional boundaries and
restrictions for the simple goal of better understanding the world."

"The Digital Millenium Copyright Act (DMCA) of 1998 makes it illegal to discuss
or provide technology that might be used to bypass industry consumer controls."
This law has been used for justify an arrest.

There is an ongoing competition in security field. Defenders and attackers try
to constantly up their game, which leads to overall more secure systems.
- Own thought on this:
	- Software complexity will increase when more security measures are
	  added. Temporarily this may lead to program instability and now this
	  needs to be fixed. At some point, there will be a need to simplify if
	  possible. After the security improvements, stability fixes and
	  simplification, the resulting program/system should be closer to
	  fulfilling its intended purpose. The amount of software/code will
	  most likely have increased from the start though. Complexity of a
	  problem dictates the minimum amount of complexity needed in a
	  solution. It is easy to misjudge the amount of complexity in both
	  problems and solutiuons.

Everyone is invited to embrace the true hacker spirit.

== 0x200 Programming ==
Programs are not necessarily executable computer programs. For example driving
instructions can be thought of as a program.

A computer does not understand English. Machine language is required in order
to communicate with a computer. As machine language consists of only bits, it
is cumbersome to work with. A translator helps a programmer in communicating
with computer more efficiently. Assemblers and compilers are translators,
assembler being the more primitive one, producing machine languge.

Pseudo-code can be used when designing a program.

Some essential concepts:
    * branching/if statements
    * variables
    * loops
        * while
        * for
        * until
    * arithmetic operators
    * comparison operators
    * functions

$ objdump -M intel -D ./a.out | grep -A20 main.:
$ objdump --disassembler-options intel --disassemble-all ./a.out | grep -A20 main.:

64-bit processors have 48-bit address space. They can also run in 32-bit
compatibility mode.

The processor can be instructed to:
    * read/write memory
    * perform math
    * be interrupted

In addition to RAM, processors can operate on registers, which can store
bits/bytes.

Registers:
    * EAX <- Accumulator
    * EBX <- Base
    * ECX <- Counter
    * EDX <- Data
    * ESP <- Stack Pointer
    * EBP <- Base Pointer
    * ESI <- Source Index
    * EDI <- Destination Index
    * EIP <- Instruction Pointer
    * EFLAGS <- bit flags for comparisons and memory segmentation

$ gcc -g firstprog.c # -g for getting debug symbols. For examle 'list' won't work otherwise

$ gdb -q ./a.out

(gdb) set disassembly intel # This command can be added to ~/.gdbinit
(gdb) list
(gdb) break 8
(gdb) run
(gdb) x/5i $pc # x = examine memory address(es)
(gdb) x/5i $eip
(gdb) x/x $eip
(gdb) x/8xb $eip
(gdb) stepi
(gdb) help p
(gdb) printf "%c", *(char *)<address>
(gdb) printf "%s", (char *)<address>
(gdb) info registers
(gdb) c # continue
(gdb) display/i $pc

Intel syntax Assembly:
operation <destination>, <source> ; usually

(gdb) disassemble main
(gdb) info register eip
(gdb) i r eip

On x86 processor, values are stored in little-endian byte order. So
(gdb) x/4xb $eip
0x8048384 <main+16>: 0xc7	0x45	0xfc	0x00
becomes
(gdb) x/2xh $eip
0x8048384 <main+16>: 0x45c7	0x00fc
(gdb) x/1xw $eip
0x8048384 <main+16>: 0x00fc45c7

$ bc -ql # Calculator from the command line. Calculating according to wrong byte order
199*(256^3) + 19*(256^2) + 252*(256^1) + 0*(256^0)

An instruction may be 7 bytes long
(gdb) x/i $eip
0x8048384 <main+16>:	mov	DWORD PTR [ebp-4],0x0
(gdb) x/7b $eip
0x8048384 <main+16>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00
$ objdump -M intel -D ./a.out | grep -A10 main.: | grep "DWORD PTR \[ebp-4\]"
8048384:	c7 45 fc 00 00 00 00	mov	DWORD PTR [ebp-4],0x0
804838b:	83 7d fc 09		cmp	DWORD PTR [ebp-4],0x9
The two instructions (mov & cmp) are 2 subsequent instructions.

<Bookmark> On page 31

== 0x300 Exploitation ==
== 0x400 Networking ==
== 0x500 Shellcode ==
== 0x600 Countermeasures ==
== 0x700 Cryptology ==
== 0x800 Conclusion ==
